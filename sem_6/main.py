# Задача  - Найти Паллиндром если да - вывести "да", если нет - "нет"

# s = 'а роза уПала нА лапу Азора'

# def pallindrom (str):
#     print(f'Исходная строка: {str}')
#     s = str.lower()
#     s = s.replace(' ', '')
#     l = len(s)
#     for i in range (0, l//2):
#         if s[i] != s[l-i-1]:
#             return "No"
#     return "Yes"
  
# print(pallindrom(s))

# -------- через рекурсию
# def poli(s):
#     if len(s) in [1,2]:
#         return s[0] == s[-1]
#     return s[0] == s[-1] and poli(s[1:len(s)-1])

# a = "abccba"
# print(poli(a))

# ----------------------------------------
# Задача No35. Решение в группах
# Напишите функцию, которая принимает одно число и проверяет, является ли оно простым
# Напоминание: Простое число - это число, которое имеет 2 делителя: 1 и n(само число)
# Input: 5 Output: yes (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31)

# n=17

# def prostoe(n, div = 2):
#     while div != n:
#         if n % div == 0:
#             return "No"
#         else:
#             return prostoe(n, div + 1)
#     return "Yes"
    
# print(prostoe(n))


# def checkPrime(n, div=2):
#     # div- дополнительный параметр для проверки на делимость. При вызове должен быть равен 2 т.к. первое простое число 2
#     if n < 2:  # если меьше то не простое
#         return False
#     elif n == 2:  # если два то сразу простое
#         return True
#     elif n % div == 0:  # если делится на 2 без остатка сразу выходим - не простое
#         return False
#     elif (
#         div * div > n # div < n / 2
#     ):  # Проверка что делитель на меньше половины от числа т.к. все что больше половины будет остаток поэтому смысла дальше проверять нет
#         return checkPrime(n, div + 1)
#     else:
#         return True

# Дан массив, состоящий из целых чисел. Напишите программу,
#  которая в данном массиве определит количество элементов,
# у которых два соседних и, при этом, оба соседних элемента меньше данного. 
# Сначала вводится число N — количество элементов в массиве Далее записаны N чисел — элементы массива.
# Массив состоит из целых чисел.
# Ввод: Ввод:
# 55
# 1 2 3 4 5 15151
# Вывод: Вывод:
# 02

# Дан массив, состоящий из целых чисел. Напишите
# программу, которая в данном массиве определит
# количество элементов, у которых два соседних и, при
# этом, оба соседних элемента меньше данного. Сначала
# вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив
# состоит из целых чисел.
# Ввод: Ввод:
# 5 5
# 1 2 3 4 5 1 5 1 5 1
# Вывод: Вывод:
# 0 2
# (каждое число вводится с новой строки)

# from random import randint

# n = 20
# list = []
# for i in range(n):
#     list.append(randint(1,10))
# print(list)
# counter = 0
# for i  in range(1, n - 1):
#     if list[i-1] < list[i] > list[i+1]:
#         counter +=1
#         print(f"{list[i]} - [{i}],", end=' ')
# print(f' :[{counter}]')

# Задача №45. Решение в группах
# Два различных натуральных числа n и m называются
# дружественными, если сумма делителей числа n
# (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа.
# По данному числу k выведите все пары дружественных
# чисел, каждое из которых не превосходит k. Программа
# получает на вход одно натуральное число k, не
# превосходящее 10>5. Программа должна вывести все
# пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в
# строке, разделяя пробелами. Каждая пара должна быть
# выведена только один раз (перестановка чисел новую
# пару не дает).
# Ввод: 300  Вывод: 220 284

def friendly_numbers(num: int) -> int:
    div_sum = 0
    for i in range(1, num//2+1):
        if num % i == 0:
            div_sum += i
    return div_sum

k = int(input())
result = []

for i in range(k):
    second = friendly_numbers(i)
    first = friendly_numbers(second)
    if i == first and i != second:
        if (second, i) not in result:
            result.append((i, second))
print(result)

## еще вариант решения

n = int(input())
list_1 = list()
for i in range(n):
    summa = 0
    for j in range(1, i // 2 + 1):
        if i % j == 0:
            summa += j
    list_1.append(tuple([i, summa]))
for i in range(len(list_1)):
    for j in range(i, len(list_1)):
        if i != j and list_1[i][0] == list_1[j][1] and list_1[i][1] == list_1[j][0]:
            print(*list_1[i])

## еще вариант решения
def s(n):
    list1 = [i for i in range(1,n) if n % i == 0]
    sum = 0
    for i in list1:
        sum += i
        # print(i)
    return sum    
    
k = 300
for i in range(1,k):
    for j in range(1,k):
        if s(i) == j and s(j) == i and i != j:
            print(f"{i} и {j}")